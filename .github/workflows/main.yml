name: build-kernel-and-repack-boot

on:
  workflow_dispatch:
    inputs:
      kernel_repo:
        description: "Kernel git repo URL"
        required: true
        default: "https://github.com/whatawurst/android_kernel_sony_msm8998.git"
      kernel_branch:
        description: "Preferred kernel branch (will auto-fallback if not found)"
        required: true
        default: "lineage-22.0"
      defconfig:
        description: "Kernel defconfig name (optional; build_kernel.sh will auto-pick if missing/wrong)"
        required: true
        default: "lineage_yoshino_defconfig"

jobs:
  build:
    runs-on: ubuntu-22.04
    env:
      TZ: Asia/Tokyo

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install deps
        run: |
          set -eux
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            bc bison build-essential ccache curl flex git libelf-dev libssl-dev \
            python3 unzip zlib1g-dev lz4 ca-certificates file \
            gcc-aarch64-linux-gnu gcc-arm-linux-gnueabihf \
            android-tools-mkbootimg

          mkbootimg --help | head -n 10 || true
          unpack_bootimg --help | head -n 10 || true

      # ---- Select kernel branch (auto fallback) ----
      - name: Select kernel branch (auto fallback)
        id: pick_branch
        run: |
          set -eux
          REPO="${{ inputs.kernel_repo }}"
          PREFERRED="${{ inputs.kernel_branch }}"

          pick() {
            b="$1"
            if git ls-remote --heads "$REPO" "refs/heads/$b" | grep -q "refs/heads/$b"; then
              echo "$b"
              return 0
            fi
            return 1
          }

          for b in "$PREFERRED" lineage-22 lineage-21.0 lineage-21 lineage-20.0 lineage-20 lineage-19.1 lineage-19; do
            if pick "$b" >/dev/null; then
              echo "branch=$b" >> "$GITHUB_OUTPUT"
              echo "Selected branch: $b"
              exit 0
            fi
          done

          echo "ERROR: No suitable branch found on $REPO"
          exit 1

      # ---- Unpack base boot using unpack_bootimg ----
      - name: Unpack base boot (cfg + ramdisk + dtb)
        run: |
          set -eux
          test -f boot.img

          rm -rf unpack
          mkdir -p unpack
          cp boot.img boot-base.img

          unpack_bootimg --boot_img boot-base.img --out unpack

          echo "Unpacked files:"
          ls -lah unpack

          # Save dtb (name differs by tool versions)
          if [ -f unpack/dtb ]; then
            cp unpack/dtb unpack/base_dtb
          elif [ -f unpack/kernel_dtb ]; then
            cp unpack/kernel_dtb unpack/base_dtb
          else
            echo "ERROR: no dtb found in unpack output!"
            ls -lah unpack
            exit 1
          fi

          # Save ramdisk (name differs by tool versions)
          if [ -f unpack/ramdisk ]; then
            cp unpack/ramdisk unpack/base_ramdisk
          elif [ -f unpack/ramdisk.gz ]; then
            cp unpack/ramdisk.gz unpack/base_ramdisk
          else
            echo "ERROR: no ramdisk found in unpack output!"
            ls -lah unpack
            exit 1
          fi

          test -f unpack/bootimg.cfg
          echo "---- bootimg.cfg ----"
          cat unpack/bootimg.cfg
          echo "---------------------"

      # ---- Build kernel (Image.gz) ----
      - name: Build kernel (Image.gz)
        env:
          KERNEL_GITHUB_TOKEN: ${{ secrets.KERNEL_GITHUB_TOKEN }}
        run: |
          set -eux
          test -f ./build_kernel.sh
          chmod +x ./build_kernel.sh

          ./build_kernel.sh "${{ inputs.kernel_repo }}" "${{ steps.pick_branch.outputs.branch }}" "${{ inputs.defconfig }}"

          test -f out/Image.gz
          ls -lah out/Image.gz

      # ---- Repack boot with mkbootimg (replace kernel only; reuse ramdisk + dtb) ----
      - name: Repack boot (mkbootimg)
        run: |
          set -eux

          KERNEL_NEW="out/Image.gz"
          RAMDISK="unpack/base_ramdisk"
          DTB="unpack/base_dtb"
          CFG="unpack/bootimg.cfg"

          test -f "$KERNEL_NEW"
          test -f "$RAMDISK"
          test -f "$DTB"
          test -f "$CFG"

          get_cfg() {
            local k="$1"
            grep -E "^${k}=" "$CFG" | head -n 1 | cut -d= -f2-
          }

          PAGESIZE="$(get_cfg pagesize)"
          BASE="$(get_cfg base)"
          KERNEL_OFFSET="$(get_cfg kernel_offset)"
          RAMDISK_OFFSET="$(get_cfg ramdisk_offset)"
          SECOND_OFFSET="$(get_cfg second_offset)"
          TAGS_OFFSET="$(get_cfg tags_offset)"
          NAME="$(get_cfg name)"
          CMDLINE="$(get_cfg cmdline)"
          OS_VERSION="$(get_cfg os_version)"
          OS_PATCH_LEVEL="$(get_cfg os_patch_level)"
          HEADER_VERSION="$(get_cfg header_version)"

          : "${HEADER_VERSION:=0}"
          : "${PAGESIZE:=4096}"
          : "${BASE:=0x00000000}"
          : "${KERNEL_OFFSET:=0x00008000}"
          : "${RAMDISK_OFFSET:=0x01000000}"
          : "${SECOND_OFFSET:=0x00f00000}"
          : "${TAGS_OFFSET:=0x00000100}"
          : "${NAME:=}"
          : "${CMDLINE:=}"
          : "${OS_VERSION:=15.0.0}"
          : "${OS_PATCH_LEVEL:=2024-11}"

          echo "mkbootimg params:"
          echo "  header_version=$HEADER_VERSION"
          echo "  pagesize=$PAGESIZE"
          echo "  base=$BASE"
          echo "  kernel_offset=$KERNEL_OFFSET"
          echo "  ramdisk_offset=$RAMDISK_OFFSET"
          echo "  second_offset=$SECOND_OFFSET"
          echo "  tags_offset=$TAGS_OFFSET"
          echo "  os_version=$OS_VERSION"
          echo "  os_patch_level=$OS_PATCH_LEVEL"
          echo "  name=$NAME"
          echo "  cmdline=$CMDLINE"

          mkbootimg \
            --header_version "$HEADER_VERSION" \
            --pagesize "$PAGESIZE" \
            --base "$BASE" \
            --kernel_offset "$KERNEL_OFFSET" \
            --ramdisk_offset "$RAMDISK_OFFSET" \
            --second_offset "$SECOND_OFFSET" \
            --tags_offset "$TAGS_OFFSET" \
            --kernel "$KERNEL_NEW" \
            --ramdisk "$RAMDISK" \
            --dtb "$DTB" \
            --cmdline "$CMDLINE" \
            --os_version "$OS_VERSION" \
            --os_patch_level "$OS_PATCH_LEVEL" \
            --name "$NAME" \
            -o boot-nfc.img

          ls -lah boot-nfc.img
          sha256sum boot-nfc.img | tee boot-nfc.img.sha256

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: boot-nfc
          path: |
            boot-nfc.img
            boot-nfc.img.sha256
            unpack/bootimg.cfg
            unpack/base_dtb
            unpack/base_ramdisk
